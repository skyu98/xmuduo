# 1.PollPoller整体架构
这里的```Channel```类似于之前的```Event```结构体，大同小异。还是调用```poll()```来监听事件数组。之前是直接通过```pollfd```，来完成对对应的```fd```的操作；这里是使用```Channel```来进行了包装，起到了更安全更方便的作用。

另外，增加了“暂时不关注该fd”的功能。
```cpp
// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
if (channel->isNoneEvent())
{
    // 暂时忽略该文件描述符的事件
    pfd.fd = -channel->fd()-1;	// 这样子设置是为了removeChannel优化
}
```

# 2.如何做到安全
既然对```fd```进行了包装，那么它和```Channel```就有了一一对应关系。
Muduo使用：
    1.```Channel```中包含一个```fd```，建立```Channel```到```fd```的关联；
    2.一个```Map<int, channel*>```来建立```fd```到```Channel```的关联；


一旦加入事件数组，```Channel```和事件数组中的```pollfd```也就有了一一对应关系.
    1.```Channel```中也包含一个```index```，建立```Channel```到数组中```pollfd```的关联；
    2.```pollfd```到```Channel```的关联，也是通过```Map<int, channel*>```来建立；

这样，每次有操作，都会在这几个方向上做对应的检查，确保各对象之间的对应关系。

# 3.如何做到高效
首先结构上，没有其他的变化，只是多了一个```Map<int, channel*>```。但是其操作时间复杂度都是```O(1)```的。

在从事件数组中删除某```pollfd```时，如果直接删除，有两个不好的后果：
* 1.数组中的元素下标会改变，这样```Channel```到数组中```pollfd```的关联就会失效；
* 2.涉及大量元素的搬移，时间复杂度太高；

所以这里采用了经典的“先交换再删除”的方法：把要删除的元素与尾部元素交换，再```pop_back()```，这样时间复杂度是```O(1)```。

我们仍然需要记录下```index```的改变。假设要删除的元素为$x$，末尾元素为$tail$，所以要通过```Map<int, channel*>```找到$tail$对应的```Channel```，将其中的```index```更改为$x$的```index```。

这样，就明白为什么暂不关注时，为什么不直接设置为-1了。
```cpp
// 将一个通道暂时更改为不关注事件，但不从Poller中移除该通道
if (channel->isNoneEvent())
{
    // 暂时忽略该文件描述符的事件
    pfd.fd = -channel->fd()-1;	// 这样子设置是为了removeChannel优化
}
```
因为如果设置为-1，在交换时末尾元素恰好是这样的事件，那么我们就无法去通过此```fd```去找到对应的```Channel```，从而更改其中的```index```。
而像上面这样设置，我们在发现末尾元素小于0时，直接取反就可以知道其原来的```fd```了。